/* ************************************************************************** */
/*                                              ############       ####       */
/*                                              ############       ####       */
/*   s21_list.h                                             ####       ####   */
/*                                                          ####       ####   */
/*   By: hubertfu@student.21-school.ru              ########           ####   */
/*                                                  ########           ####   */
/*                                              ####                   ####   */
/*   Created: 2022-10-11                        ####                   ####   */
/*   Updated: 2022-11-22                            ############       ####   */
/*                                                  ############       ####   */
/* ************************************************************************** */

/**
 * @file s21_list.h
 * @author Hubert Furr (hubertfu@student.21-school.ru)
 * @brief s21::list (список) - это контейнер, который поддерживает вставку и
 * удаление элементов с постоянным временем из любого места в контейнере.
 * Быстрый произвольный доступ не поддерживается. Реализован в виде двусвязного
 * списка.
 *
 * Добавление, удаление и перемещение элементов в списке или в нескольких
 * списках не делает недействительными итераторы или ссылки. Итератор становится
 * недействительным только при удалении соответствующего элемента.
 *
 * В списке всегда присутствует служебная нода head_ (даже в пустом списке) -
 * она необходима для организации кольцевого двунаправленного списка - подробное
 * описание в классе итератора ниже
 *
 * @version 2.0
 * @date 2022-11-22
 *
 * @copyright hubertfu (c) 2022
 */

#ifndef S21_CONTAINERS_S21_CONTAINERS_S21_LIST_H_
#define S21_CONTAINERS_S21_CONTAINERS_S21_LIST_H_

#include <initializer_list>
#include <iterator>
#include <limits>

namespace s21 {
template <typename Type>
class list {
  private:
    struct ListNode;
    struct ListIterator;
    struct ListIteratorConst;

  public:
    // Тип элемента (Type — параметр шаблона)
    using value_type = Type;
    // Тип ссылки на элемент
    using reference = Type &;
    // Тип константной ссылки на элемент
    using const_reference = const Type &;
    // Внутренний класс для итератора
    using iterator = ListIterator;
    // Внутренний класс для константного итератора
    using const_iterator = ListIteratorConst;
    // Тип для размера контейнера
    using size_type = std::size_t;

    // Внутренний класс узла списка
    using node_type = ListNode;

    /**
     * @brief Конструктор по умолчанию, создает пустой список
     */
    list() : head_(new node_type{}), size_(0U) {
    }

    /**
     * @brief Параметризированный конструктор, создает список размера n c
     * дефолтной инициализацией типа данных.
     *
     * @param n Размер создаваемого списка
     */
    explicit list(size_type n) : list() {
        while (n > 0) {
            push_back(value_type{});
            --n;
        }
    }

    /**
     * @brief Конструктор списка инициализаторов, создает список,
     * инициализированный с помощью std::initializer_list.
     *
     * @param items Список создаваемых элементов
     */
    list(std::initializer_list<value_type> const &items) : list() {
        for (auto item : items) {
            push_back(item);
        }
    }

    /**
     * @brief Конструктор копирования (Copy Constructor). Создает список путем
     * копирования данных из объекта other.
     *
     * @param other копируемый объект
     */
    list(const list &other) : list() {
        for (auto list_element : other) {
            push_back(list_element);
        }
    }

    /**
     * @brief Конструктор переноса (Move Constructor). Создает список путем
     * передачи владения ресурсами от объекта other.
     *
     * @param other переносимый объект
     */
    list(list &&other) noexcept : list() {
        splice(begin(), other);
    }

    /**
     * @brief Оператор присваивания копированием.
     *
     * @details В принципе можно сделать clear(), а затем аналогично
     * copy-конструктору заполнить список. Но мы  хотим как и std::list
     * переиспользовать память, которая уже выделена (Otherwise, the memory
     * owned by *this may be reused when possible.)
     *
     * Это позволяет избежать лишних операций очистки и выделения новой памяти,
     * что заметно экономит время. Список в 200 000 элементов заменяем списком в
     * 200 000 элементов:
     * - Без переиспользования памяти: ~40ms
     * - C переиспользованием памяти: ~3ms
     *
     * @param other Копируемый список
     * @return list& Созданная копия
     */
    list &operator=(const list &other) {
        if (this != &other) {
            iterator this_begin = begin();
            iterator this_end = end();
            const_iterator other_begin = other.begin();
            const_iterator other_end = other.end();

            // Сначала заполняем уже существующие элементы в текущем списке,
            // пока они не кончатся, либо пока не кончатся элементы в other
            while (this_begin != this_end && other_begin != other_end) {
                *this_begin = *other_begin;
                ++this_begin;
                ++other_begin;
            }

            // Если в текущем элементе остались элементы, то удаляем их
            while (this_begin != this_end) {
                iterator tmp = this_begin;
                ++this_begin;
                erase(tmp);
            }

            // Если в other остались элементы, то пушим их в текущий список
            while (other_begin != other_end) {
                push_back(*other_begin);
                ++other_begin;
            }
        }

        return *this;
    }

    /**
     * @brief Оператор присваивания переносом
     *
     * @param other Перемещаемый список
     * @return list& Результат перемещения
     */
    list &operator=(list &&other) noexcept {
        if (this != &other) {
            clear();
            splice(begin(), other);
        }
        return *this;
    }

    /**
     * @brief Деструктор объекта (Destructor)
     */
    ~list() {
        clear();
        delete head_;
        // Для избежания сбоев при повторном освобождении указателей и повторном
        // использовании указателей
        head_ = nullptr;
    }

    /**
     * @brief Доступ к первому элементу контейнера.
     * @details Для непустого контейнера s выражение s.front() эквивалентно
     * *s.begin(). Использование на пустом контейнере UB - никак с этим не
     * боремся
     *
     * @return reference
     */
    reference front() noexcept {
        return *begin();
    }

    /**
     * @brief Доступ к первому элементу константного контейнера.
     *
     * @return const_reference
     */
    const_reference front() const noexcept {
        return *begin();
    }

    /**
     * @brief Доступ к последнему элементу контейнера.
     * @details Для непустого контейнера s выражение s.back() эквивалентно
     * *std::prev(s.end()). Использование на пустом контейнере UB - никак с этим
     * не боремся.
     *
     * @return reference
     */
    reference back() noexcept {
        return *std::prev(end());
    }

    /**
     * @brief Доступ к последнему элементу константного контейнера.
     *
     * @return const_reference
     */
    const_reference back() const noexcept {
        return *std::prev(end());
    }

    /**
     * @brief Возвращает итератор на начало контейнера.
     * @details Для пустого контейнера возвращаемый итератор будет равен end().
     *
     * @return iterator
     */
    iterator begin() noexcept {
        return iterator{head_->next_};
    }

    /**
     * @brief Версия begin() для const
     *
     * @return const_iterator
     */
    const_iterator begin() const noexcept {
        return const_iterator{head_->next_};
    }

    /**
     * @brief Возвращает итератор на конец контейнера (элемент после последнего
     * элемента контейнера).
     * @details Элемент является служебной "заглушкой" и его разыменование - UB
     *
     * @return iterator
     */
    iterator end() noexcept {
        return iterator{head_};
    }

    /**
     * @brief Версия end() для const
     *
     * @return const_iterator
     */
    const_iterator end() const noexcept {
        return const_iterator{head_};
    }

    /**
     * @brief Проверяет, является ли контейнер пустым
     *
     * @return true контейнер пустой
     * @return false контейнер непустой
     */
    bool empty() const noexcept {
        return size_ == 0;
    }

    /**
     * @brief Возвращает количество элементов в контейнере
     *
     * @return size_type
     */
    size_type size() const noexcept {
        return size_;
    };

    /**
     * @brief Возвращает максимальное количество элементов, которое может
     * содержать контейнер из-за ограничений реализации системы или библиотеки.
     *
     * @warning В реальности значение max_size() никогда не будет достижимо.
     *
     * @details Это число не зависит от состояния ОС или доступной памяти, а
     * определяется только реализацией контейнера. Во время выполнения размер
     * контейнера может быть ограничен значением, меньшим max_size(), чем объем
     * доступной оперативной памяти.
     *
     * Для расчета используются следующие вводные:
     * 1) Размер size_t должен совпадать с размером указателя для любой
     * платформы. Указатель должен быть в состоянии адресовать любой байт в
     * памяти, а size_t хранить размер любого (в т.ч. занимающего всю память)
     * объекта. Таким образом максимальное значение size_t - это максимальное
     * количество байт памяти. Это значение мы получаем при помощи
     * std::numeric_limits<size_t>::max();
     *
     * 2) GCC ограничивает объекты размером в половину адресного пространства.
     * (https://gcc.gnu.org/legacy-ml/gcc/2011-08/msg00221.html).
     * Фактически это выглядит как использование signed size_t и, насколько я
     * понял, решает в т.ч. проблемы из-за смешивания знаковых и беззнаковых
     * типов (правила такого смешивания очень неожиданные) - Вычисление разницы
     * между двумя указателями, по-видимому, рассматривается gcc как вычитание
     * целых чисел со знаком.
     * Поэтому полученное в п.1 число делим на 2.
     *
     * А вообще сам Бьёрн Страуструп признал, что использование size_t для
     * размеров контейнеров в STL было ошибкой
     * (https://www.youtube.com/watch?v=Puio5dly9N8 - в 42:38 и 1:02:50), так
     * что по-хорошему надо было бы сразу использовать знаковый тип, который бы
     * и ограничил максимальное количество элементов таким же образом.
     *
     * 3) Чтобы определить максимальное количество элементов в контейнере, делим
     * число, полученное в п.2, на размер одного элемента, т.е.
     * sizeof(node_type)
     *
     * 4) Насколько я понимаю, в std::list на этом всё заканчивается, но я
     * вычитаю еще 1 из результата, т.к. пустой list уже содержит один узел (на
     * который указывает end()), т.е. реальное количество элементов будет на 1
     * меньше, чем количество выделенной памяти.
     *
     * @return size_type Максимальное количество элементов
     */
    size_type max_size() const noexcept {
        return ((std::numeric_limits<size_type>::max() / 2) /
                sizeof(node_type)) -
               1;
    }

    /**
     * @brief Удаляет содержимое контейнера (все элементы). Контейнер при этом
     * остается консистентным.
     */
    void clear() noexcept {
        while (size_ > 0) {
            erase(begin());
        }
    }

    /**
     * @brief Вставляет элемент перед pos со значением value и возвращает
     * итератор, указывающий на добавленный элемент.
     * @details Strong exception guarantee
     *
     * @param pos
     * @param value
     * @return iterator
     */
    iterator insert(iterator pos, const_reference value) {
        node_type *new_node = new node_type(value);

        pos.node_->AttachPrev(new_node);
        ++size_;

        return iterator(new_node);
    }

    /**
     * @brief Удаляет элемент в позиции pos.
     * @details Нельзя использовать на end() - документация запрещает, а так в
     * std можно удалить end() и получить неконсистентный объект
     *
     * @param pos
     */
    void erase(iterator pos) noexcept {
        if (pos != end()) {
            pos.node_->UnAttach();
            delete pos.node_;
            --size_;
        }
    }

    /**
     * @brief Добавляет элемент в конце списка
     * @details Strong exception guarantee
     *
     * @param value
     */
    void push_back(const_reference value) {
        insert(end(), value);
    }

    /**
     * @brief Удаляет последний элемент списка
     * @details Вызов функции на пустом контейнере - UB. ССылки и итераторы на
     * удаленный элемент становятся невалидными
     */
    void pop_back() noexcept {
        erase(--end());
    }

    /**
     * @brief Добавляет элемент в начало списка
     * @details Strong exception guarantee
     *
     * @param value
     */
    void push_front(const_reference value) {
        insert(begin(), value);
    }

    /**
     * @brief Удаляет первый элемент списка
     * @details Вызов функции на пустом контейнере - UB. ССылки и итераторы на
     * удаленный элемент становятся невалидными
     */
    void pop_front() noexcept {
        erase(begin());
    }

    /**
     * @brief Обменивает содержимое двух списков
     * @details Не производится никаких операций копирования, перемещения или
     * обмена конкретных элементов. Все итераторы и ссылки остаются валидными,
     * end() после операции будет указывать на другой контейнер.
     *
     * @param other
     */
    void swap(list &other) noexcept {
        if (this != &other) {
            std::swap(head_, other.head_);
            std::swap(size_, other.size_);
        }
    }

    /**
     * @brief Объединяет два отсортированных списка в один.
     * @details Strong exception guarantee
     * Контейнер other всегда становится пустым после операции. Если списки не
     * отсортированы, то объединение все равно происходит, просто алгоритм
     * рассчитан на то, что списки уже отсортированы, поэтому мы экономим время
     * на сортировке результата и результат не будет отсортированным, если
     * списки на входе не отсортированы
     *
     * @param other
     */
    void merge(list &other) {
        if (this != &other) {
            iterator this_begin = begin();
            iterator this_end = end();
            iterator other_begin = other.begin();
            iterator other_end = other.end();

            // Идем по this и other, пока не дойдем до конца одного из списков
            while (this_begin != this_end && other_begin != other_end) {
                if (*other_begin < *this_begin) {
                    // Если элемент в other меньше текущего в this, от отцепляем
                    // его от other и прицепляем в текущую позицию this
                    node_type *tmp = other_begin.node_;
                    // И сдвигаем итератор на следующий элемент other
                    ++other_begin;
                    tmp->UnAttach();
                    --other.size_;
                    this_begin.node_->AttachPrev(tmp);
                    ++size_;
                } else {
                    // В противном случае сдвигаем итератор this на следующий
                    // элемент
                    ++this_begin;
                }
            }

            // Оставшиеся в other элементы просто переносим, если в other ещё
            // остались элементы
            splice(end(), other);
        }
    }

    /**
     * @brief Перемещает элементы из одного списка в другой, перед позицией pos.
     * @details Не осуществляется никаких копирований или перемещений объектов,
     * только перепривязываются внутренние указатели узлов. Контейнер other
     * всегда становится пустым после операции. Все итераторы и ссылки остаются
     * валидными, но указывают теперь на *this
     *
     * The behavior is undefined if other refers to the same object as *this.
     *
     * @param pos
     * @param other
     */
    void splice(const_iterator pos, list &other) noexcept {
        if (!other.empty()) {
            iterator it_current{const_cast<node_type *>(pos.node_)};
            iterator it_other = other.end();

            it_other.node_->next_->prev_ = it_current.node_->prev_;
            it_other.node_->prev_->next_ = it_current.node_;

            it_current.node_->prev_->next_ = it_other.node_->next_;
            it_current.node_->prev_ = it_other.node_->prev_;

            size_ += other.size();

            other.size_ = 0;
            other.head_->next_ = other.head_;
            other.head_->prev_ = other.head_;
        }
    }

    /**
     * @brief Переворачивает порядок элементов в списке
     * @details Методы свапа ноды в std скомпилированы в отдельную библиотеку с
     * оптимизацией. Поэтому наше решение может конкурировать с оригиналом
     * только при компиляции с -O3
     *
     */
    void reverse() noexcept {
        iterator begin_iterator = begin();
        iterator end_iterator = end();
        while (begin_iterator != end_iterator) {
            begin_iterator.node_->SwapNextPrev();
            --begin_iterator;
        }
        head_->SwapNextPrev();
    }

    /**
     * @brief Удаляет из списка повторяющиеся элементы.
     * @details Речь про повторяющиеся подряд элементы, т.е. из списка
     * {1,1,2,2,1,2} получится {1,2,1,2}
     *
     */
    void unique() {
        iterator begin_iterator = begin();
        iterator end_iterator = end();
        iterator prev_iterator = begin_iterator;

        ++begin_iterator;
        while (begin_iterator != end_iterator) {
            if (*begin_iterator == *prev_iterator) {
                erase(begin_iterator);
                begin_iterator = prev_iterator;
            } else {
                ++prev_iterator;
            }
            ++begin_iterator;
        }
    }
    /**
     * @brief Сортирует элементы списка в порядке возрастания. Метод вызывает
     * быструю сортировку
     */
    void sort() {
        quick_sort(begin(), --end(), size_);
    }

    // Эта версия emplace() соответствует реализации в std::list
    // Оставлена справочно и для разрешения спорных вопросов при проверках (если
    // проверяющий склоняется к версии, что именно так надо было делать)
    /**
     * @brief Размещает новый элемент в контейнер непосредственно перед pos.
     * @details Аргументы args... пересылаются конструктору элемента как
     * std::forward<Args>(args)...
     * Основное отличие от insert - избежать ненужных копирований объекта,
     * единожды созданный временный объект будет передаваться по функциям без
     * копирования и встроится в список.
     *
     * Это полезно, потому что независимо от того, насколько умны RVO и
     * семантика перемещения, все еще есть сложные случаи, когда insert,
     * push_back и т.д., вероятно, сделают ненужные копии.
     *
     * Никакие итераторы или ссылки не становятся недействительными.
     *
     * Strong exception guarantee.
     *
     * @tparam Args Пакет параметров шаблона (Parameter pack)
     * @param pos Итератор, перед которым будет размещён новый элемент.
     * @param args Аргументы для передачи конструктору элемента.
     * @return iterator Итератор, указывающий на размещенный элемент.
     */

    /**
     * @brief Размещает новые элементы args в контейнер непосредственно перед
     * pos.
     * @details Модифицированная версия метода emplace, в целом идейно повторяет
     * emplace() из std (см. описание предыдущей функции), но получает в
     * качестве аргументов args уже созданные объекты для размещения в
     * контейнере (а не параметры для конструирования объектов)
     *
     * @tparam Args Args Пакет параметров шаблона (Parameter pack)
     * @param pos Итератор, перед которым будет размещён новый элемент.
     * @param args Уже созданные элементы, которые необходимо вставить в
     * соответствующий контейнер.
     * @return iterator Итератор, указывающий на последний размещенный элемент.
     */
    template <typename... Args>
    iterator emplace(const_iterator pos, Args &&...args) {
        iterator it_current{const_cast<node_type *>(pos.node_)};
        node_type *new_node;

        for (auto item : {std::forward<Args>(args)...}) {
            new_node = new node_type(std::move(item));
            it_current.node_->AttachPrev(new_node);
            ++size_;
        }

        return iterator(new_node);
    }

    /**
     * @brief Размещает новый элемент в конце контейнера.
     * @details В остальном полностью идентичен emplace()
     *
     * @tparam Args Пакет параметров шаблона (Parameter pack)
     * @param args Аргументы для передачи конструктору элемента.
     */
    template <typename... Args>
    void emplace_back(Args &&...args) {
        emplace(end(), std::forward<Args>(args)...);
    }

    /**
     * @brief Размещает новый элемент в начале контейнера.
     * @details В остальном полностью идентичен emplace()
     *
     * @tparam Args Пакет параметров шаблона (Parameter pack)
     * @param args Аргументы для передачи конструктору элемента.
     */
    template <typename... Args>
    void emplace_front(Args &&...args) {
        emplace(begin(), std::forward<Args>(args)...);
    }

  private:
    /**
     * @brief Приватная функция, реализующая алгоритм быстрой сортировки.
     * (см. https://w.wiki/5r2i)
     *
     * @details Один из самых быстродействующих (на практике) из алгоритмов
     * внутренней сортировки общего назначения. Работает на связных списках и
     * других структурах с последовательным доступом, допускающих эффективный
     * проход как от начала к концу, так и от конца к началу.
     *
     * У алгоритма есть проблемы, которые будут разобраны ниже, после примера.
     *
     * В самом простом варианте алгоритм выглядит так:
     * 1) Выбрать элемент из массива (Опорный элемент).
     * 2) Перераспределить элементы в массиве таким образом, что элементы,
     * меньшие опорного, помещаются перед ним, а большие или равные - после.
     * 3) Рекурсивно применить первые два шага к двум подмассивам слева и справа
     * от опорного элемента. Рекурсия не применяется к массиву, в котором только
     * один элемент или отсутствуют элементы.
     *
     * В самой простой (и тупой) реализации это будет выглядеть так:
     * Возьмем для примера {6,6,9,7,2,4}
     * 1) Опорным всегда выбираем последний элемент, т.е. 4
     * 2) Проходим по порядку элементы:
     * 6 > 4 - не трогаем
     * 6 > 4 - не трогаем
     * 9 > 4 - не трогаем
     * 7 > 4 - не трогаем
     * 2 < 4 - свапаем 6 и 2, итератор места для свапа сдвигаем на +1
     * Список кончился, свапаем опорный элемент и место для свапа, т.е. 6 и 4
     * Итого: {2,4,9,7,6,6}
     * 3) Делим список на 2 подсписка (слева и справа от опорного элемента):
     * {2}
     * {9,7,6,6}
     *
     * 4) Повторяем весь алгоритм для каждого подсписка (рекурсивно)
     * {2}:
     * 1) Ничего не делаем, т.к. один элемент
     * {9,7,6,6}
     * 1) Опорный - 6
     * 2) Проходим по порядку элементы:
     * 9 > 6 - не трогаем
     * 7 > 6 - не трогаем
     * 6 = 6 - свапаем 9 и 6, итератор места для свапа сдвигаем на +1
     * Список кончился, свапаем опорный элемент и место для свапа, т.е. 7 и 6
     * Итого: {6,6,9,7}
     * 3) Делим список на 2 подсписка (слева и справа от опорного элемента):
     * {6}
     * {9,7}
     *
     * 4) Повторяем весь алгоритм для каждого подсписка (рекурсивно)
     * {6}:
     * 1) Ничего не делаем, т.к. один элемент
     * {9,7}
     * 1) Опорный - 7
     * 2) Проходим по порядку элементы:
     * 9 > 7 - не трогаем
     * Список кончился, свапаем опорный элемент и место для свапа, т.е. 9 и 7
     * Итого:
     * {7,9}
     * 3) Делим список на 2 подсписка (слева и справа от опорного элемента):
     * {}
     * {9}
     *
     * Оба списка далее не обрабатываются, т.к. размер не более 1.
     * Итого у нас отсортированный список: {2,4,6,6,7,9}
     *
     *
     * ПРОБЛЕМЫ И УЛУЧШЕНИЯ
     * ВАЖНО: Часть пунктов приведены справочно, но реализовано не всё, а только
     * пункты, которые дают заметный прирост скорости (ведь у нас нет задачи
     * реализовать идеальную сортировку - тем более часто наш алгоритм и так
     * быстрее, чем std - см. тесты)
     *
     * 1) Сильно деградирует по скорости (до O(n^2)) в худшем или близком к нему
     * случае, что может случиться при неудачных входных данных. Для
     * двусвязного списка самый простой и очевидный выбор опорного элемента -
     * первый или последний.
     *
     * 1.1) Неудачные входные данные - уже отсортированный массив. Для
     * двусвязного списка самый простой и очевидный выбор опорного элемента -
     * первый или последний. Но если опорный элемент каждый раз оказывается
     * минимумом или максимумом (что как раз и происходит в отсортированном
     * массиве), то сортировка максимально деградирует по скорости.
     * РЕШЕНИЕ: Выбирать в качестве опорного элемента всегда средний элемент
     * диапазона.
     *
     * Данное решение мы РЕАЛИЗУЕМ (см. комментарии по коду).
     *
     * 1.2) Неудачные входные данные - специально подобранные плохие данные.
     * Например, для алгоритма 1.1, их специально подбирают, чтобы средний
     * элемент оказывался каждый раз минимумом. РЕШЕНИЕ: Случайный выбор
     * опорного элемента (но желательно в районе центра). Вероятность случайного
     * возникновения худшего случая становится исчезающе малой, а намеренный
     * подбор — практически неосуществимым.
     *
     * Данное решение мы не РЕАЛИЗУЕМ, т.к. вероятность такого случайного набора
     * очень мала, а против специальных саботажей в нашем случае бороться
     * нецелесообразно на мой взгляд.
     *
     * 1.3) Вообще чем на более равные части будет делиться массив - тем лучше.
     * Потому в качестве опорного наиболее эффективно брать медианное значение.
     * Кроме того это снижает вероятность возникновения худшего случая, по
     * сравнению с выбором среднего элемента (но не защищает от специально
     * подобранных данных)
     *
     * Данное решение мы не РЕАЛИЗУЕМ, т.к. выигрыш не такой огромный, а
     * реализация сложнее, чем 1.1.
     *
     * ВАЖНО: Недостаток всех усложнённых методов выбора опорного элемента —
     * дополнительные накладные расходы. НО в целом они не так велики и дают в
     * среднем прирост скорости.
     *
     * 1.4) Неудачные входные данные - в исходном массиве много одинаковых
     * элементов. Это сильно замедляет алгоритм, ведь равные опорному элементы
     * также, как и опорный, уже попали на свое место в отсортированном списке,
     * но мы все равно их передаем на следующие уровни рекурсии.
     *
     * РЕШЕНИЕ: Разделять список не на две, а на три части (меньше опорного,
     * равные опорному, больше опорного). На следующий уровень мы передаём
     * только списки меньше опорного и больше опорного.
     *
     * Данное решение мы РЕАЛИЗУЕМ (см. комментарии по коду).
     *
     * 1.5) Касательно выбора опорного элемента - можно реализовать выбор
     * лучшего значения опорного элемента при обнаружении "плохого" выбора
     * (если, например, разделение очень неравномерное). Кроме выбора медианного
     * значения можно использовать медиану медиан ещё.
     *
     * Это мы тоже НЕ РЕАЛИЗУЕМ по очевидным причинам
     *
     * 2) Прямая реализация в виде функции с двумя рекурсивными вызовами может
     * привести к ошибке переполнения стека, так как в худшем случае ей может
     * потребоваться сделать O(n) вложенных рекурсивных вызовов (которые будут
     * хранить в т.ч. локальные переменные).
     *
     * РЕШЕНИЕ: вообще решений существует несколько (в т.ч. довольно сложных,
     * например, эмулировать стек программно), но мы рассмотрим только вариант
     * "Разделять список не на две, а на три части". Это сокращает глубину
     * рекурсии и увеличивает скорость (как описано в 1.4)
     *
     * Данное решение мы уже РЕАЛИЗОВАЛИ в 1.4.
     *
     * 3) Из-за рекурсии и других "накладных расходов" алгоритм может оказаться
     * не столь уж быстрым для коротких массивов. Поэтому, если в массиве меньше
     * N элементов (зависит от реализации, обычно от 3 до 40), вызывается
     * сортировка вставками. Увеличение скорости может составлять до 15%.
     *
     * Данное решение мы не РЕАЛИЗУЕМ, т.к. выигрыш не такой огромный.
     *
     * 4) Неустойчивость алгоритма - сортировка меняет относительный порядок
     * сортируемых элементов, имеющих одинаковое значение.
     *
     * РЕШЕНИЕ: Расширение ключа исходным индексом элемента в списке.
     *
     * Данное решение мы не РЕАЛИЗУЕМ, т.к. оно только замедлит скорость, а
     * скорость нам важнее, чем устойчивость (в большинстве задач это не важно).
     *
     * @param left Итератор, указывающий на первый элемент сортируемого
     * диапазона.
     * @param right Итератор, указывающий на последний элемент сортируемого
     * диапазона.
     * @param list_size Количество элементов в сортируемом диапазоне.
     */
    void quick_sort(iterator left, iterator right, size_type list_size) {
        // Выполняем сортировку, если есть что сортировать (в т.ч. это является
        // условием выхода из рекурсии)
        if (left != right && list_size > 1) {
            // Итератор элемента, в который будут свапаться элементы меньше
            // опорного
            iterator swap_iterator = left;
            // Итератор на элемент, являющийся опорным
            iterator pivot_iterator = left;
            // Внутренний экземляр итератора, указывающий на начало
            // обрабатываемого диапазона
            iterator tmp_left = left;
            // Внутренний экземляр итератора, указывающий на конец
            // обрабатываемого диапазона
            iterator tmp_right = right;
            // Сдвигаем итераторы на -1, т.к. это законно всегда (у нас
            // зацикленные итераторы) и этого требует логика нашего алгоритма
            --swap_iterator;
            --pivot_iterator;
            // Целочисленный счетчик, чтобы в процессе считать сдвиги и итоговый
            // размер
            size_type ishift = 0;
            // Выбор опорного элемента (Реализуем выбор среднего элемента)
            while (ishift < list_size / 2) {
                ++pivot_iterator;
                ++ishift;
            }
            // Сохраняем полученное значение опорного элемента
            value_type pivot = *pivot_iterator;
            // Обнуляем наш счетчик, он нам еще пригодится
            ishift = 0;

            // Меняем опорный элемент с самым правым в списке, чтобы он не
            // участвовал в промежуточных перестановках (обход всего списка
            // никогда не включает в себя самый правый элемент)
            pivot_iterator.node_->SwapValues(right.node_);

            // Начинаем обход нашего списка, все перемещения элементов делаем
            // обменом
            while (tmp_left != tmp_right) {
                if (*tmp_left < pivot) {
                    // Все элементы, меньше опорного, закидываем по порядку в
                    // начало списка
                    ++swap_iterator;
                    ++ishift;
                    tmp_left.node_->SwapValues(swap_iterator.node_);
                    ++tmp_left;
                } else if (*tmp_left == pivot) {
                    // все элементы, равные опорному, закидываем в конец списка,
                    // начиная с предпоследнего и движемся влево (последнее
                    // место у нас занимает опорный элемент и он в обходе не
                    // участвует)
                    --tmp_right;
                    tmp_left.node_->SwapValues(tmp_right.node_);
                } else {
                    // В остальных случаях движемся дальше по списку
                    ++tmp_left;
                }
            }

            // Далее мы разбиваем наш список на два подсписка.
            // Итератор на последний элемент первого списка
            iterator next_step_left = swap_iterator;
            // Количество элементов в 1м списке
            size_type next_step_left_size = ishift;
            // Количество элементов во 2м списке
            size_type next_step_right_size = list_size - ishift - 1;

            // Переносим все элементы из конца списка, равные опорному, после
            // последнего элемента, меньше опорного
            ++swap_iterator;
            while (tmp_right != right) {
                swap_iterator.node_->SwapValues(tmp_right.node_);
                ++swap_iterator;
                ++tmp_right;
                --next_step_right_size;
            }

            // Переносим наш опорный элемент из конца списка к другим элементам,
            // равным ему
            swap_iterator.node_->SwapValues(right.node_);
            ++swap_iterator;

            // Итератор на первый элемент второго списка
            iterator next_step_right = swap_iterator;

            // Вызываем рекурсивно эту же функцию для обоих полученных
            // подсписков Если подсписки пустые - ничего страшного, внутри есть
            // проверка на это
            quick_sort(left, next_step_left, next_step_left_size);
            quick_sort(next_step_right, right, next_step_right_size);
        }
    }

    /**
     * @brief Класс, реализующий узел двусвязного списка
     */
    struct ListNode {
        /**
         * @brief Конструктор по умолчанию для создания пустого узла списка, с
         * дефолтной инициализацией значения узла
         */
        ListNode() noexcept : next_(this), prev_(this), value_(value_type{}) {
        }
        /**
         * @brief Конструктор, создающий узел списка, инициализированный
         * значением value
         *
         * @param value значение для инициализации узла
         */
        explicit ListNode(const_reference value) noexcept
            : next_(nullptr), prev_(nullptr), value_(value) {
        }
        /**
         * @brief Конструктор, создающий узел списка, инициализированный
         * значением value, используя move-семантику. Очень актуально для тех
         * случаев, когда для создания узла используется временный уже
         * сконструированный объект, например, в emplace()
         *
         * @param value значение для инициализации узла
         */
        explicit ListNode(value_type &&value) noexcept
            : next_(nullptr), prev_(nullptr), value_(std::move(value)) {
        }

        /**
         * @brief Встраивает узел new_node перед текущим узлом
         *
         * @param new_node Встраиваемый узел
         */
        void AttachPrev(node_type *new_node) noexcept {
            new_node->next_ = this;
            new_node->prev_ = prev_;
            prev_->next_ = new_node;
            prev_ = new_node;
        }

        /**
         * @brief Изымает узел из списка
         */
        void UnAttach() noexcept {
            prev_->next_ = next_;
            next_->prev_ = prev_;
            next_ = this;
            prev_ = this;
        }

        /**
         * @brief Меняет значения текущего узла и узла other_node
         *
         * @param other_node
         */
        void SwapValues(node_type *other_node) noexcept {
            std::swap(value_, other_node->value_);
        }

        /**
         * @brief Обменивает next_ и prev_ текущего узла
         */
        void SwapNextPrev() noexcept {
            std::swap(next_, prev_);
        }

        // Указатель на следующий узел списка
        node_type *next_;
        // Указатель на предыдущий узел списка
        node_type *prev_;
        // Значение узла списка
        value_type value_;
    };

    /**
     * @brief Класс итератора для списка
     *
     * @details У нас реализован кольцевой двунаправленный список, где один из
     * элементов является головой. Указатель next из него рассматривается как
     * указатель на первый элемент списка, а prev -- на последний. Естественным
     * образом указатель next у последнего элемента и prev у первого  будет
     * указывать на эту голову.
     *
     * Голова является служебным элементом и присутствует даже у пустого списка.
     * У пустого списка у головы next и  prev указывают на голову.
     *
     * Таким образом обход списка через ++ и -- будет всегда зациклен:
     * ++: предпоследний -> последний -> end() -> первый
     * --: первый -> end() -> последний -> предпоследний
     */
    struct ListIterator {
        // C++ ожидает от итератора некоторых свойств, их наличие позволяет
        // использовать с итераторами функции из других библиотек и
        // оптимизировать алгоритмы, работающие с ними. Например, мы теперь
        // можем использовать std::next с нашим итератором. Вот эти пять свойств
        // нужны:
        using iterator_category = std::bidirectional_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = list::value_type;
        using pointer = value_type *;
        using reference = value_type &;

        /**
         * @brief Дефолтный конструктор запрещен, т.к. пустой итератор нам не
         * нужен
         */
        ListIterator() = delete;

        /**
         * @brief Основной конструктор. Помечаем основной конструктор как
         * explicit, чтобы избежать сюрпризов из-за неявных преобразований - мы
         * всегда должны четко указывать, что хотим при создании итератора
         *
         * @param node указатель на узел, на который будет указывать итератор
         */
        explicit ListIterator(node_type *node) noexcept : node_(node) {
        }

        /**
         * @brief Получение указателя на значение узла, на который указывает
         * итератор.
         *
         * @return reference
         */
        reference operator*() const noexcept {
            return node_->value_;
        }

        /**
         * @brief Префиксное перемещение итератора вперед для обращения к
         * следующему элементу.
         *
         * @return iterator& ссылка на новый элемент
         */
        iterator &operator++() noexcept {
            node_ = node_->next_;
            return *this;
        }

        /**
         * @brief Постфиксное перемещение итератора вперед для обращения к
         * следующему элементу.
         *
         * @return iterator значение до перемещения
         */
        iterator operator++(int) noexcept {
            iterator tmp{node_};
            ++(*this);
            return tmp;
        }

        /**
         * @brief Префиксное перемещение итератора назад для обращения к
         * предыдущему элементу.
         *
         * @return iterator& ссылка на новый элемент
         */
        iterator &operator--() noexcept {
            node_ = node_->prev_;
            return *this;
        }

        /**
         * @brief Постфиксное перемещение итератора вперед для обращения к
         * следующему элементу.
         *
         * @return iterator значение до перемещения
         */
        iterator operator--(int) noexcept {
            iterator tmp{node_};
            --(*this);
            return tmp;
        }

        /**
         * @brief Два итератора равны, если они указывают на один и тот же
         * элемент.
         *
         * @param other
         * @return true  - равны
         * @return false - неравны
         */
        bool operator==(const iterator &other) const noexcept {
            return node_ == other.node_;
        }

        /**
         * @brief Два итератора не равны, если они указывают на разные элементы.
         *
         * @param other
         * @return true  - неравны
         * @return false - равны
         */
        bool operator!=(const iterator &other) const noexcept {
            return node_ != other.node_;
        }

        // Указатель на узел, на который указывает итератор
        node_type *node_;
    };

    /**
     * @brief Класс константного итератора для списка. Используется в тех
     * случаях, когда итератор не должен позволят менять элементы списка,
     * например, для const list
     *
     * @details В целом идентичен обычному итератору, но имеет следующие
     * отличия:
     * - pointer и reference объявлены как const
     * - поле node_ класса объявлено как const
     * - имеет дополнительный конструктор для конструирования объекта из
     * обычного итератора (нужен для неявного преобразования iterator в
     * const_iterator)
     * - операторы == и != перегружены как дружественные, чтобы при сравнении
     * неconst и const происходило неявное преобразование неconst в const
     */
    struct ListIteratorConst {
        using iterator_category = std::bidirectional_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = list::value_type;
        using pointer = const value_type *;
        using reference = const value_type &;

        ListIteratorConst() = delete;

        explicit ListIteratorConst(const node_type *node) : node_(node) {
        }

        ListIteratorConst(const iterator &it) : node_(it.node_) {
        }

        reference operator*() const noexcept {
            return node_->value_;
        }

        const_iterator &operator++() noexcept {
            node_ = node_->next_;
            return *this;
        }

        const_iterator operator++(int) noexcept {
            const_iterator tmp{node_};
            ++(*this);
            return tmp;
        }

        const_iterator &operator--() noexcept {
            node_ = node_->prev_;
            return *this;
        }

        const_iterator operator--(int) noexcept {
            const_iterator tmp{node_};
            --(*this);
            return tmp;
        }

        friend bool operator==(const const_iterator &it1,
                               const const_iterator &it2) noexcept {
            return it1.node_ == it2.node_;
        }

        friend bool operator!=(const const_iterator &it1,
                               const const_iterator &it2) noexcept {
            return it1.node_ != it2.node_;
        }

        const node_type *node_;
    };

    // Указатель на голову списка
    node_type *head_;
    // Количество элементов в списке
    size_type size_;
};

}  // namespace s21

#endif  // S21_CONTAINERS_S21_CONTAINERS_S21_LIST_H_
